### CPU 스케줄링 방법 중 다음과 같은 상황을 해결하기 위한 방법을 한 단어로 적으시오. 
- A 은행 입구에 있는 순번대기표 생성기는 "특정 시간 내에 처리해야 하는 중요한 업무가 있는 고객을 위하여 0~99번까지," 그렇지 않은 일반 업무가 있는 고객을 위하여 100~140번까지 번호를 생성한다.
- 고객이 은행에 도착했을 때 업무의 중요도에 따라서 적절한 번호를 부여 받게 되며, 낮은 숫자의 번호표를 가진 고객의 업무를 먼저 처리한다. 
- 박과장의 순번대기표는 130번이다. 그런데 오늘 따라 중요한 업무를 처리하기 위한 고객이 끊이지 않아 박 과장 업무 처리를 하지 못하고 계속 기다리고만 있다.
==> 선점 기법 

- CPU 스케줄링
  - 선점스케줄링
    - 하나의 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 프로세서를 빼앗을 수 있는 방법
    - 우선 순위가 높은 프로세스가 CPU를 먼저 차지하기가 용이하기 때문에 시분할 시스템에서 사용. 
    - 많은 오버헤드를 초래. 
  - 비선점스케줄링
    - 프로세스에게 이미 할당된 CPU를 강제로 뺴앗을 수 없고, 그 프로세스의 사용이 끝난 후에 스케줄링을 하여야 하는 방법
    - 모든 프로세스들에 대한 요구를 공정히 처리
    - 응답 시간의 예측이 용이

### 알고리즘 효율성
- 데이터의 수가 예측 불가한 상황에서 알고리즘 A와 B중 IT관점에서 우수한 알고리즘을 선택하고 그 이유를 설명하시오.
  - 데이터의 수가 증가하는 비율에 비해 연산횟수 증가율이 낮아야 좋은 알고리즘이다. 
  - 즉, 공간복잡도에 비해 시간복잡도 증가율이 낮아야 한다. 

### register
- cpu와 가까운 레지스터 공간을 사용

### 이상현상
- 이상현상이란, 테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상이다.
- 테이블을 잘못 설계하여 삽입, 삭제, 갱신할 때 오류가 발생하게 되는 것이다.

### 동시성 제어
- 동시에 실행되는 여러 개의 트랜잭션이 작업을 성공적으로 마칠 수 있또록 트랜잭션의 실행 순서를 제어하는 기법

## 네트워크 및 보안
### 
- BPSK : 1 bits
- QPSK : 2 bits
- 8PSK : 3 bits
- 16QAM : 4 bits

### MTU(Maxium Transmission Unit)
- 플래그
  - fragmentation이 됐는지 안 됐는지 나타내주는 값
    - 1 : 뒤에 단편화 된 패킷이 존재한다.
    - 0 : 뒤에 단편화 된 패킷이 존재하지 않는다.
- 오프셋 
  - 전체 패킷에서의 위치
    - 첫번째 flag의 offset 값은 0이다.
    - 두번째부터는 flag 전체 패킷을 8로 나눈다. 이렇게 하는 이유는 양이 너무 많아서 줄이기 위함이다. 
- 단편화란(Fragmentation)
  - MTU 보다 큰 데이터그램은 전송이 불가능 하기 때문에 MTU 보다 작은 크기로 만들어 주는 과정이다.
  - 세분화(Segmentation)이라고도 한다. 
  - 단편화를 거쳐서 수신지까지 도착하게 되면 수신자가 재조립(Reassembly)을 과정을 거치게 된다.
    - 재조립(Ressembly)란, 최종 수신지에 도착한 데이터그램 단편들을 수신자가 보낸 데이터그램으로 다시 조립하는 과정이다. 
- MTU가 1,500byte인 이더넷(Ethernet) 환경에서 크기가 4000byte인 데이터를 전송하기 위한 단편화 과정을 요약한 것이다.
헤더 크기가 100byte이고 오프셋이 8byte로 표현될때, 단편화 데이터3의 오프셋 값을 구하시오.
  - 원본 데이터 - 4000
  - 단편화 데이터1 - 1400 / 오프셋 0
  - 단편화 데이터2 - 1400 / 오프셋 175(1400/8 = 175)
  - 단편화 데이터3 - 1200 / 오프셋 350((1400 + 1400 ) / 8 = 350)
  
### 서브네팅(Subnetting)이란?
- IP 주소를 효율적으로 사용하기 위해서 네트워크를 나누느 과정을 말합니다.
- 자신의 네트워크를 더 작은 서브 네트워크로 나누는 것이라고 생각해주시면 됩니다.
- 앞선 IPv4의 문제를 해결하기 위하여 네트워크의 수에 따라 효율적으로 사용할 수 있도록 서브넷(Subnet)이라는 개념이 등장합니다.
- 장점
  - 1. 효율성
    - 네트워크를 나누면서 가질 수 있는 이점은 여러 가지가 있는데, 앞서 말한 것처럼 낭비되는 IP주소를 효율적으로 관리하여 사용할 수 있고, 네트워크를 나눔으로써 사용하는 용도 역시 구분할 수 있게 합니다.
  - 2. 성능
    - 성능적인 측면에서도 이점이 있는데, 데이터를 보낼 때 네트워크에 연결된 모든 호스트에 전송하는 것을 브로드캐스트(Broadcast)라고 하는데 브로드캐스팅을 하게 되면 너무 많은 트래픽(traffic)이 생기기 때문에 성능이 저하되는 문제가 발생한다.
    - 네트워크를 분리함으로써 브로드캐스트 되는 도메인의 크기가 줄어들어 트래픽을 감소시켜 성능적인 이점 역시 얻을 수 있다.
  - 3. 보안
    - 보안적인 측면에서 바라본다면, 네트워크를 분리한다는 것은 서로 다른 네트워크가 된다는 뜻이다.
    - 하나의 도메인에 모든 정보가 들어있다면 누군가로부터 공격받았을 때 모든 정보가 유출될 수 있지만, 네트워크를 여러 개로 나눔으로써 보안적으로 이점이 있다.
- 단점
  - 같은 네트워크 안에서는 2계층 장비인 스위치(Switch)를 사용하면 통신이 가능하지만, 서로 다른 네트워크와 통신하기 위해서는 3계층 장비인 라우터(Router)가 필요하다.
  - 과도한 서브네팅은 비효율
    - 서브네팅을 너무 많이 하게 되면 오히려 호율적이지 않은 상황이 생기기도 한다.
    - 너무 많이 할 경우 네트워크마다 네트워크 이름과 브로드캐스트 주소 2개의 IP가 사용되기 때문에 사용 가능한 IP가 줄어들게 된다.
    - 네트워크가 쪼개질 수록 낭비되는 IP가 많아지기 때문에 효율적이지 않을 수도 있다. 

### 공개키 암호화 종류
- RSA
  - 공개키로 암호화한 것은 개인키로 복호화할 수 있고, 개인키로 암호화한 것은 공개키로 복호화할 수 있습니다.
  - 공개키로 암호화된 내용은 개인키가 유출되지 않는 한 복호화할 수 없기 때문에, 공개키는 아무리 노출되더라도 안전합니다.

### SSL
- 1. 클라이언트가 서버에 접속한다. Client Hello 단계라 불리며, 이 때 클라이언트는 서버에게 다음과 같은 정보를 보낸다.
  - SSL버전
  - 클라이언트에서 생성한 랜덤 데이터(난수)
  - 클라이언트가 지원하는 암호화 방식 (Cipher suites)
    - 이 정보를 보내는 이유는 상호 간 어떠한 암호화 방식을 사용할 것인지 협상하기 위해서입니다.
    - 왜냐하면 서버와 클라이언트가 지원하는 암호화 방식의 차이가 있을 수 있기 때문입니다.
    - 협상해야 할 암호화 알고리즘은 4가지입니다.
      - 대칭키 교환에 사용할 암호화 알고리즘
        - 실제 데이터를 암호화할 때 사용할 대칭키(Session Key)를 교환할 때 사용할 알고리즘을 말합니다.
        - 보통 공개키 암호화 알고리즘을 사용합니다.
        - RSA, DH, DHE, ECDH, ECDHE 등 
      - 인증서 서명 알고리즘
        - 클라이언트가 서버로부터 받은 인증서를 전자서명을 통해 검증할 때 사용할 알고리즘을 말한다.
        - 보통 서버가 인증서를 발급받을 때 CSR(인증서 서명 요청)을 하는데, 이 때 선택한 알고리즘을 선택한다.
        - RSA, ECDSA, DSA
      - 대칭키 알고리즘
        - 실제 데이터를 암호화할 때 사용할 대칭키(Session Key) 암호화 알고리즘을 말합니다.
        - 대칭키 암호화 알고리즘이 블록 암호일 경우, 블록 암호 운용 방식을 설정해야 합니다.
        - AES, ARIA, 3DES 등 
      - MAC 알고리즘
        - 보통 HMAC 방식을 사용합니다.
        - SHA-1, SHA-256, MD5 등
        - Session Key와 암호화된 메세지를 협상한 해시 알고리즘에 입력하여 MAC을 생성하고, 이를 암호화된 메시지와 함께 보냅니다.
        - 수신자는 전달받은 암호화된 메시지와 session key를 협상한 해시 알고리즘에 입력하여 MAC을 생성하고 이를 전달 받은 MAC과 비교하여 데이터 무결성을 검증합니다.
  - 세션 아이디(Optional)
    - 이미 SSL handshaking을 했다면 시간과 비용을 줄이기 위해 기존 세션을 재활용하게 되는데, 이때 사용할 세션 아이디를 전송합니다.
- 2. 서버는 Client Hello 단계에 대한 응답으로 Server Hello 절차를 수행합니다. 이 때 서버가 클라이언트에게 건네는 정보는 다음과 같습니다.
  - 서버가 지원하는 SSL 버전
  - 서버에서 생성한 랜덤 데이터(난수)
  - 서버가 선택한 암호화 방식
    - 1번 단계에서 클라이언트가 보낸 암호화 방식 중 서버가 사용할 수 있는 암호화 방식을 선택하고 이에 대한 정보를 클라이언트에게 보냄으로써 협상을 종료합니다.
  - CA로부터 발급 받은 인증서 
- 3. 클라이언트는 서버로부터 받은 인증서를 검증한다.
  - 인증서를 발급한 CA가 자신의 CA리스트에 존재하는지 확인.
  - 해당 CA의 공개키로 인증서가 복호화되는지 확인.
- 4. 인증서가 정상적으로 검증되었으면, 클라이언트는 pre master secret라 불리는 랜덤 데이터를 하나 생성합니다.
  인증서에 담겨 있는 서버의 공개키를 이용해 pre master secret을 암호화하고 서버에게 전송합니다.
= 5. 클라이언트로부터 받은 pre master secret을 서버 자신의 개인키로 복호화합니다.
  이로써 pre master secret을 서버와 클라이언트가 모두 공유합니다. 서버와 클라이언트는 PRF(PseudoRandom Function) 알고리즘으로 pre master secret을 master secret 값(48bytes)으로 만듭니다.
- 6. 이렇게 만든 master secret을 통해 session key를 생성하고, 서버와 클라이언트는 Session key를 사용하여 대칭키 암호화 방식으로 데이터를 암호화하여 통신합니다.
- 7. 서버와 클라이언트 handshake 단계의 종료를 서로에게 알립니다. 

### 빅데이터 개념
- 빅데이터 분석 기법은 텍스트 마이닝, 오피니언 마이닝, 소셜 네트워크 분석, 군집 분석 등을 포함한다.
- 빅데이터의 특성을 나타내는 3V는 데이터의 양, 데이터 입출력의 속도, 그리고 데이터 종류의 다양성을 의미한다.
- 토픽 분석은 대량의 문서에서 토픽을 추출하는 기법으로, 하나의 문서가 다수의 토픽에 대응될 수 있다.

### NoSQL
- 특징
  - 거대한 Map으로서 key-value 형식을 지원
  - RDBMS는 Foreign Key, Join 등으로 관계를 정의하지만, NoSQL을 관계를 정의하지 않음
  - 대용량 데이터를 저장할 수 있음
  - 읽기/쓰기 성능이 RDBMS보다 빠름
- CAP 이론
  - 분산형 구조는 일관성(Consistency), 가용성(Availability), 분산 허용(Partitioning Tolerance)의 3가지 특징을 가지고 있다.
  - 일관성(Consistency) : 분산된 노드 중 어느 노드로 접근하더라도 데이터 값이 같아야 한다.
  - 가용성(Availability) : 클러스터링된 노드 중 하나 이상의 노드가 실패라도 정상적으로 요청을 처리할 수 있는 기능을 제공한다.
  - 분산 허용(Partitioning Tolerance) : 클러스터링 노드간에 통신하는 네트워크 장애가 나더라도 정상적으로 서비스를 수행한다. 노드 간 물리적으로 전혀 다른 네트워크 공간에 위치도 가능하다.
  - 일반적으로 RDBMS는 일관성, 가용성을 만족한다. 
  - NoSQL은 가용성, 분산허용을 만족하는 제품군과 일관성, 분산허용을 만족하는 제품군으로 나눌 수 있다.

### 프로젝트 일정관리의 프로세스들이다. 일정관리의 수행 순서를 올바르게 나열한 것을 고르시오.
- 활동 정의 > 활동 순서 배열 > 활동 자원 산정 > 활동 기간 산정 > 일정 개발 > 일정 통제


### 백업
## 백업의 목표
- RPO(recovery point objective)는 재해로 인한 데이터 손실의 허용량에 따라 백업 주기의 간격을 결정하는 지표입니다.
  - 백업 주기의 간격이 짧을수록 재해 발생 시 손실되는 데이터의 양이 적고, 
  - 주기가 길수록 손실되는 데이터의 양은 비교적 많다고 볼 수 있습니다.
  - 예를 들면 설정한 RPO가 24시간이면, 24시간 간격으로 백업이 수행됩니다.
  - 백업의 빈도.
- RTO(recovery time objective)는 재해 발생 시점으로부터 복구까지 걸리는 시간을 얼마나 허용할 수 있는지를 나타내는 지표입니다.
  - 예를 들어 설정한 RTO가 6시간이면 데이터에 접근 못하는 시간이 6시간을 넘을 경우 기업이 감내하기 힘들다는 것입니다.
  - 백업의 최소 복구 시간 

## 백업의 종류
- 전체 백업(full backup)
  - 말 그대로 원본 데이터 전체를 매번 백업하는 방식을 말합니다.
  - 가장 신뢰도가 높은 방법이지만, 시간도 많이 소모되고 한 번에 차지하는 스토리지 공간이 많습니다.
  - 이 때문에 대부분은 전체 백업을 다른 백업 기능들과 병행해서 기간을 두고 설정합니다.
- 증분 백업(incremental backup)
  - 매번 모든 데이터를 백업하지 않고 지난번 백업 데이터에서 추가 및 변경된 부분만 백업하는 방법입니다.
  - 보통 전체 백업 주기 사이에 증분 백업을 설정하고, 증분 백업 전후로 중복되는 데이터가 없기 때문에 스토리지 공간과 백업 시간을 최소화할 수 있습니다.
  - 다만, 증분 백업 데이터로 복구를 수행할 경우 시간이 오래 걸리는 단점이 있습니다.
- 차등 백업(differential backup)
  - 지난번 전체 백업에서 추가된 부분을 모두 백업하는 방법
  - 이전 차등 백업 부분을 포함해 추가된 부분까지 백업하기 때문에 증분 백업과는 약간 다릅니다.
  - 차등 백업 데이터로 복구하는 경우 증분 백업 방식에 비해 빠르다는 장점이 있습니다.
- 모범 답안
매주 일요일 00:00 ~ 05:00 Full Backup(전체 백업)
매주 월~토요일 00:00 ~ 01:00 Differential Backup(차등 백업)
매일 4시간 간격 Log Backup(아카이브 로그 백업)
- 해설
1) 총 데이터가의 사이즈가 2TB로 매일 백업을 수행하기에는 백업시간 확보에 어려움이 있으며,
고객 요구사항에 백업비용 절감을 위해 백업용량을 최소화해야 함 => 사용자가 없는 일요일 새벽시간에 주 1회 Full backup 수행.
2) MTTR 최소화를 위해 Incremental 백업보다는 Differential 백업을 매일 수행하며 백업으로 인한 업무 영향도 최소화를 위해 사용자가 없는 월~토요일 00:00~01:00에 백업 수행
(데이터 변경률이 매우 작기 때문에 백업용량 최소화 요구사항도 충족)
3) 장애 시 최대 4시간 이내 데이터 손실방지 요구사항 충족을 위해 최대 4시간 간격으로 아카이브 로그 백업을 수행

### 취약점 해결을 위해 stmt를 변경 
[기존]
String query = "SELECT * FROM 고객 WHERE 고객번호 = '" + custID + "'";
stmt = con.prepareStatement(query);
rs = stmt.executeQuery();
[변경]
String query = "SELECT * FROM 고객 WHERE 고객번호 = ? ";
PreparedStatement pstmt = con.prepareStatement(query);
psmtmt.setString(1, custId);
rs = stmt.executeQuery();
