### CPU 스케줄링 방법 중 다음과 같은 상황을 해결하기 위한 방법을 한 단어로 적으시오. 
- A 은행 입구에 있는 순번대기표 생성기는 "특정 시간 내에 처리해야 하는 중요한 업무가 있는 고객을 위하여 0~99번까지," 그렇지 않은 일반 업무가 있는 고객을 위하여 100~140번까지 번호를 생성한다.
- 고객이 은행에 도착했을 때 업무의 중요도에 따라서 적절한 번호를 부여 받게 되며, 낮은 숫자의 번호표를 가진 고객의 업무를 먼저 처리한다. 
- 박과장의 순번대기표는 130번이다. 그런데 오늘 따라 중요한 업무를 처리하기 위한 고객이 끊이지 않아 박 과장 업무 처리를 하지 못하고 계속 기다리고만 있다.
==> 선점 기법 

- CPU 스케줄링
  - 선점스케줄링
    - 하나의 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 프로세서를 빼앗을 수 있는 방법
    - 우선 순위가 높은 프로세스가 CPU를 먼저 차지하기가 용이하기 때문에 시분할 시스템에서 사용. 
    - 많은 오버헤드를 초래. 
  - 비선점스케줄링
    - 프로세스에게 이미 할당된 CPU를 강제로 뺴앗을 수 없고, 그 프로세스의 사용이 끝난 후에 스케줄링을 하여야 하는 방법
    - 모든 프로세스들에 대한 요구를 공정히 처리
    - 응답 시간의 예측이 용이

### 알고리즘 효율성
- 데이터의 수가 예측 불가한 상황에서 알고리즘 A와 B중 IT관점에서 우수한 알고리즘을 선택하고 그 이유를 설명하시오.
  - 데이터의 수가 증가하는 비율에 비해 연산횟수 증가율이 낮아야 좋은 알고리즘이다. 
  - 즉, 공간복잡도에 비해 시간복잡도 증가율이 낮아야 한다. 

### register
- cpu와 가까운 레지스터 공간을 사용

### 이상현상
- 이상현상이란, 테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상이다.
- 테이블을 잘못 설계하여 삽입, 삭제, 갱신할 때 오류가 발생하게 되는 것이다.

### 동시성 제어
- 동시에 실행되는 여러 개의 트랜잭션이 작업을 성공적으로 마칠 수 있또록 트랜잭션의 실행 순서를 제어하는 기법

## 네트워크 및 보안
### 
- BPSK : 1 bits
- QPSK : 2 bits
- 8PSK : 3 bits
- 16QAM : 4 bits

### MTU(Maxium Transmission Unit)
- 플래그
  - fragmentation이 됐는지 안 됐는지 나타내주는 값
    - 1 : 뒤에 단편화 된 패킷이 존재한다.
    - 0 : 뒤에 단편화 된 패킷이 존재하지 않는다.
- 오프셋 
  - 전체 패킷에서의 위치
    - 첫번째 flag의 offset 값은 0이다.
    - 두번째부터는 flag 전체 패킷을 8로 나눈다. 이렇게 하는 이유는 양이 너무 많아서 줄이기 위함이다. 
- 단편화란(Fragmentation)
  - MTU 보다 큰 데이터그램은 전송이 불가능 하기 때문에 MTU 보다 작은 크기로 만들어 주는 과정이다.
  - 세분화(Segmentation)이라고도 한다. 
  - 단편화를 거쳐서 수신지까지 도착하게 되면 수신자가 재조립(Reassembly)을 과정을 거치게 된다.
    - 재조립(Ressembly)란, 최종 수신지에 도착한 데이터그램 단편들을 수신자가 보낸 데이터그램으로 다시 조립하는 과정이다. 
- MTU가 1,500byte인 이더넷(Ethernet) 환경에서 크기가 4000byte인 데이터를 전송하기 위한 단편화 과정을 요약한 것이다.
헤더 크기가 100byte이고 오프셋이 8byte로 표현될때, 단편화 데이터3의 오프셋 값을 구하시오.
  - 원본 데이터 - 4000
  - 단편화 데이터1 - 1400 / 오프셋 0
  - 단편화 데이터2 - 1400 / 오프셋 175(1400/8 = 175)
  - 단편화 데이터3 - 1200 / 오프셋 350((1400 + 1400 ) / 8 = 350)
  
### 서브네팅(Subnetting)이란?
- IP 주소를 효율적으로 사용하기 위해서 네트워크를 나누느 과정을 말합니다.
- 자신의 네트워크를 더 작은 서브 네트워크로 나누는 것이라고 생각해주시면 됩니다.
- 앞선 IPv4의 문제를 해결하기 위하여 네트워크의 수에 따라 효율적으로 사용할 수 있도록 서브넷(Subnet)이라는 개념이 등장합니다.
- 장점
  - 1. 효율성
    - 네트워크를 나누면서 가질 수 있는 이점은 여러 가지가 있는데, 앞서 말한 것처럼 낭비되는 IP주소를 효율적으로 관리하여 사용할 수 있고, 네트워크를 나눔으로써 사용하는 용도 역시 구분할 수 있게 합니다.
  - 2. 성능
    - 성능적인 측면에서도 이점이 있는데, 데이터를 보낼 때 네트워크에 연결된 모든 호스트에 전송하는 것을 브로드캐스트(Broadcast)라고 하는데 브로드캐스팅을 하게 되면 너무 많은 트래픽(traffic)이 생기기 때문에 성능이 저하되는 문제가 발생한다.
    - 네트워크를 분리함으로써 브로드캐스트 되는 도메인의 크기가 줄어들어 트래픽을 감소시켜 성능적인 이점 역시 얻을 수 있다.
  - 3. 보안
    - 보안적인 측면에서 바라본다면, 네트워크를 분리한다는 것은 서로 다른 네트워크가 된다는 뜻이다.
    - 하나의 도메인에 모든 정보가 들어있다면 누군가로부터 공격받았을 때 모든 정보가 유출될 수 있지만, 네트워크를 여러 개로 나눔으로써 보안적으로 이점이 있다.
- 단점
  - 같은 네트워크 안에서는 2계층 장비인 스위치(Switch)를 사용하면 통신이 가능하지만, 서로 다른 네트워크와 통신하기 위해서는 3계층 장비인 라우터(Router)가 필요하다.
  - 과도한 서브네팅은 비효율
    - 서브네팅을 너무 많이 하게 되면 오히려 호율적이지 않은 상황이 생기기도 한다.
    - 너무 많이 할 경우 네트워크마다 네트워크 이름과 브로드캐스트 주소 2개의 IP가 사용되기 때문에 사용 가능한 IP가 줄어들게 된다.
    - 네트워크가 쪼개질 수록 낭비되는 IP가 많아지기 때문에 효율적이지 않을 수도 있다. 

### 공개키 암호화 종류
- RSA
  - 공개키로 암호화한 것은 개인키로 복호화할 수 있고, 개인키로 암호화한 것은 공개키로 복호화할 수 있습니다.
  - 공개키로 암호화된 내용은 개인키가 유출되지 않는 한 복호화할 수 없기 때문에, 공개키는 아무리 노출되더라도 안전합니다.

### SSL
- 1. 클라이언트가 서버에 접속한다. Client Hello 단계라 불리며, 이 때 클라이언트는 서버에게 다음과 같은 정보를 보낸다.
  - SSL버전
  - 클라이언트에서 생성한 랜덤 데이터(난수)
  - 클라이언트가 지원하는 암호화 방식 (Cipher suites)
    - 이 정보를 보내는 이유는 상호 간 어떠한 암호화 방식을 사용할 것인지 협상하기 위해서입니다.
    - 왜냐하면 서버와 클라이언트가 지원하는 암호화 방식의 차이가 있을 수 있기 때문입니다.
    - 협상해야 할 암호화 알고리즘은 4가지입니다.
      - 대칭키 교환에 사용할 암호화 알고리즘
        - 실제 데이터를 암호화할 때 사용할 대칭키(Session Key)를 교환할 때 사용할 알고리즘을 말합니다.
        - 보통 공개키 암호화 알고리즘을 사용합니다.
        - RSA, DH, DHE, ECDH, ECDHE 등 
      - 인증서 서명 알고리즘
        - 클라이언트가 서버로부터 받은 인증서를 전자서명을 통해 검증할 때 사용할 알고리즘을 말한다.
        - 보통 서버가 인증서를 발급받을 때 CSR(인증서 서명 요청)을 하는데, 이 때 선택한 알고리즘을 선택한다.
        - RSA, ECDSA, DSA
      - 대칭키 알고리즘
        - 실제 데이터를 암호화할 때 사용할 대칭키(Session Key) 암호화 알고리즘을 말합니다.
        - 대칭키 암호화 알고리즘이 블록 암호일 경우, 블록 암호 운용 방식을 설정해야 합니다.
        - AES, ARIA, 3DES 등 
      - MAC 알고리즘
        - 보통 HMAC 방식을 사용합니다.
        - SHA-1, SHA-256, MD5 등
        - Session Key와 암호화된 메세지를 협상한 해시 알고리즘에 입력하여 MAC을 생성하고, 이를 암호화된 메시지와 함께 보냅니다.
        - 수신자는 전달받은 암호화된 메시지와 session key를 협상한 해시 알고리즘에 입력하여 MAC을 생성하고 이를 전달 받은 MAC과 비교하여 데이터 무결성을 검증합니다.
  - 세션 아이디(Optional)
    - 이미 SSL handshaking을 했다면 시간과 비용을 줄이기 위해 기존 세션을 재활용하게 되는데, 이때 사용할 세션 아이디를 전송합니다.
- 2. 서버는 Client Hello 단계에 대한 응답으로 Server Hello 절차를 수행합니다. 이 때 서버가 클라이언트에게 건네는 정보는 다음과 같습니다.
  - 서버가 지원하는 SSL 버전
  - 서버에서 생성한 랜덤 데이터(난수)
  - 서버가 선택한 암호화 방식
    - 1번 단계에서 클라이언트가 보낸 암호화 방식 중 서버가 사용할 수 있는 암호화 방식을 선택하고 이에 대한 정보를 클라이언트에게 보냄으로써 협상을 종료합니다.
  - CA로부터 발급 받은 인증서 
- 3. 클라이언트는 서버로부터 받은 인증서를 검증한다.
  - 인증서를 발급한 CA가 자신의 CA리스트에 존재하는지 확인.
  - 해당 CA의 공개키로 인증서가 복호화되는지 확인.
- 4. 인증서가 정상적으로 검증되었으면, 클라이언트는 pre master secret라 불리는 랜덤 데이터를 하나 생성합니다.
  인증서에 담겨 있는 서버의 공개키를 이용해 pre master secret을 암호화하고 서버에게 전송합니다.
= 5. 클라이언트로부터 받은 pre master secret을 서버 자신의 개인키로 복호화합니다.
  이로써 pre master secret을 서버와 클라이언트가 모두 공유합니다. 서버와 클라이언트는 PRF(PseudoRandom Function) 알고리즘으로 pre master secret을 master secret 값(48bytes)으로 만듭니다.
- 6. 이렇게 만든 master secret을 통해 session key를 생성하고, 서버와 클라이언트는 Session key를 사용하여 대칭키 암호화 방식으로 데이터를 암호화하여 통신합니다.
- 7. 서버와 클라이언트 handshake 단계의 종료를 서로에게 알립니다. 

